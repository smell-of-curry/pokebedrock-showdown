"use strict";

const fs = require("fs");
const child_process = require("child_process");
const esbuild = require('esbuild');
const path = require('path');

const copyOverDataJSON = (file = 'data') => {
	const files = fs.readdirSync(file);
	for (const f of files) {
		if (fs.statSync(`${file}/${f}`).isDirectory()) {
			copyOverDataJSON(`${file}/${f}`);
		} else if (f.endsWith('.json')) {
			fs.copyFileSync(`${file}/${f}`, require('path').resolve('dist', `${file}/${f}`));
		}
	}
};

const shouldBeCompiled = file => {
	if (file.includes('node_modules/')) return false;
	if (file.endsWith('.tsx')) return true;
	if (file.endsWith('.ts')) return !(file.endsWith('.d.ts') || file.includes('global'));
	return false;
};

const findFilesForPath = path => {
	const out = [];
	const files = fs.readdirSync(path);
	for (const file of files) {
		const cur = `${path}/${file}`;
		// HACK: Logs and databases exclusions are a hack. Logs is too big to
		// traverse, databases adds/removes files which can lead to a filesystem
		// race between readdirSync and statSync. Please, at some point someone
		// fix this function to be more robust.
		if (cur.includes('node_modules') || cur.includes("/logs") || cur.includes("/databases")) continue;
		if (fs.statSync(cur).isDirectory()) {
			out.push(...findFilesForPath(cur));
		} else if (shouldBeCompiled(cur)) {
			out.push(cur);
		}
	}
	return out;
};

exports.transpile = decl => {
    // @pokebedrock - Generate the Dex static module map before building, so imports resolve
    try {
        generateDexModuleMap();
    } catch (e) {
		console.error('Failed to generate Dex module map', e);
	}

    // @pokebedrock - Generate the Random Battles static module map before building
    try {
        generateRandomBattlesModuleMap();
    } catch (e) {
		console.error('Failed to generate Random Battles module map', e);
	}

    esbuild.buildSync({
		entryPoints: findFilesForPath('./'),
		outdir: './dist',
		outbase: '.',
		format: 'cjs',
		tsconfig: './tsconfig.json',
		sourcemap: true,
	});
	fs.copyFileSync('./config/config-example.js', './dist/config/config-example.js');
	copyOverDataJSON();

	// NOTE: replace is asynchronous - add additional replacements for the same path in one call instead of making multiple calls.
	if (decl) {
		exports.buildDecls();
	}
};

exports.buildDecls = () => {
	try {
		child_process.execSync(`node ./node_modules/typescript/bin/tsc -p sim`, { stdio: 'inherit' });
	} catch {}
};

// @pokebedrock - generate dex-module-map.ts
function generateDexModuleMap() {
    const root = path.resolve('.');
    const simDir = path.join(root, 'sim');
    const dataDir = path.join(root, 'data');
    const modsDir = path.join(dataDir, 'mods');
    const DATA_FILE_BASENAMES = [
        'abilities', 'rulesets', 'formats-data', 'items', 'learnsets', 'moves',
        'natures', 'pokedex', 'pokemongo', 'scripts', 'conditions', 'typechart',
    ];

    /**
     * Build import entries with keys matching the runtime keys used in sim/dex.ts:
     * '../data/<basename>' and '../data/mods/<mod>/<basename>'
     */
    const importEntries = [];

    // base data
    for (const base of DATA_FILE_BASENAMES) {
        const tsPath = path.join(dataDir, `${base}.ts`);
        const jsPath = path.join(dataDir, `${base}.js`);
        if (fs.existsSync(tsPath) || fs.existsSync(jsPath)) {
            const key = `../data/${base}`;
            const importPath = `../data/${base}`;
            importEntries.push({ key, importPath });
        }
    }

    // mods
    if (fs.existsSync(modsDir) && fs.statSync(modsDir).isDirectory()) {
        for (const mod of fs.readdirSync(modsDir)) {
            const modPath = path.join(modsDir, mod);
            if (!fs.statSync(modPath).isDirectory()) continue;
            for (const base of DATA_FILE_BASENAMES) {
                const tsPath = path.join(modPath, `${base}.ts`);
                const jsPath = path.join(modPath, `${base}.js`);
                if (fs.existsSync(tsPath) || fs.existsSync(jsPath)) {
                    const key = `../data/mods/${mod}/${base}`;
                    const importPath = `../data/mods/${mod}/${base}`;
                    importEntries.push({ key, importPath });
                }
            }
        }
    }

    // Build TypeScript file with static imports and a map export
    const lines = [];
    lines.push('// @pokebedrock - This file is AUTO-GENERATED by `tools/build-utils.js`.');
    lines.push('');
    lines.push('export const DexMods: string[] = [');

    // Write 7 mods per line, with a space between each mod
    let modCount = 0;
    let currentLine = '';
    const modList = [];
    for (const entry of importEntries) {
        if (!entry.key.includes('mods/')) continue;
        const mod = entry.key.split('/')[3];
        if (modList.includes(mod)) continue;

        modList.push(mod);
        if (modCount >= 7) {
            lines.push(currentLine);
            currentLine = '';
            modCount = 0;
        }
        currentLine += `${modCount > 0 ? ' ' : '\t'}'${mod}',`;
        modCount++;
    }
    if (modList.length > 0) {
        lines.push(currentLine);
    }

    lines.push('];');
    lines.push('');
    lines.push('export const DexModuleMap: Record<string, any> = {');
    let lastMod = '';
    importEntries.forEach((entry) => {
        // Add a space if its a different mod
        if (entry.key.includes('mods/')) {
            const mod = entry.key.split('/')[3];
            if (mod !== lastMod) {
                lines.push('');
                lines.push(`\t// ${mod}`);
                lastMod = mod;
            }
        }
        lines.push(`\t'${entry.key}': require('${entry.importPath}'),`);
    });
    lines.push('};');
    lines.push('');

    const outPath = path.join(simDir, 'dex-module-map.ts');
    fs.writeFileSync(outPath, lines.join('\n'));
}

// @pokebedrock - generate random-battles-module-map.ts
function generateRandomBattlesModuleMap() {
    const root = path.resolve('.');
    const simDir = path.join(root, 'sim');
    const rbDir = path.join(root, 'data', 'random-battles');

    if (!fs.existsSync(rbDir) || !fs.statSync(rbDir).isDirectory()) return;

    const subdirs = fs.readdirSync(rbDir)
        .filter(d => fs.statSync(path.join(rbDir, d)).isDirectory())
        .filter(d => {
            const dir = path.join(rbDir, d);
            const hasTS = fs.existsSync(path.join(dir, 'teams.ts'));
            const hasJS = fs.existsSync(path.join(dir, 'teams.js'));
            return hasTS || hasJS;
        })
        .sort();

    const lines = [];
    lines.push('// @pokebedrock - This file is AUTO-GENERATED by `tools/build-utils.js`.');
    lines.push('');
    lines.push('export const RandomBattlesMods: string[] = [');

    // Write 7 mods per line
    let count = 0;
    let currentLine = '';
    for (const mod of subdirs) {
        if (count >= 7) {
            lines.push(currentLine);
            currentLine = '';
            count = 0;
        }
        currentLine += `${count > 0 ? ' ' : '\t'}'${mod}',`;
        count++;
    }
    if (subdirs.length > 0) lines.push(currentLine);

    lines.push('];');
    lines.push('');
    lines.push('export const RandomBattlesModuleMap: Record<string, any> = {');
    for (const mod of subdirs) {
        lines.push(`\t'${mod}': require('../data/random-battles/${mod}/teams'),`);
    }
    lines.push('};');
    lines.push('');

    const outPath = path.join(simDir, 'random-battles-module-map.ts');
    fs.writeFileSync(outPath, lines.join('\n'));
}
